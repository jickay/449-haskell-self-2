
==================== FINAL INTERFACE ====================
2018-03-09 22:41:52.6202187 UTC

interface main:Main 8022
  interface hash: c54ccc9da1f907f01bb597b34d4a1fc6
  ABI hash: c67ecbc62cbae6b6266b5af0cdfd5a0a
  export-list hash: 34e7efa8403f70a6098268b353e3a431
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 49bc03923b6b72218773bcd45aaea9d8
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.forcedMatchValid
  Main.main
  Main.makeSolution
  Main.solutionValid
module dependencies:
package dependencies: base-4.10.1.0* ghc-prim-0.5.1.1
                      integer-gmp-1.0.1.0 jkfso-haskell-0.1.0.0
orphans: base-4.10.1.0:GHC.Float base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Type.Equality base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
import  -/  base-4.10.1.0:Data.List e5312e282ad78d8152090e079f862b53
import  -/  base-4.10.1.0:Data.OldList fdea655c7bec488a3994df222c677ab7
import  -/  base-4.10.1.0:GHC.Base 8f949d675e49677c272f02ab7a85fe18
import  -/  base-4.10.1.0:GHC.List 1bb0adf79553530dc898796596e53188
import  -/  base-4.10.1.0:GHC.Show 927ef590f679632bf94869e8018e5b48
import  -/  base-4.10.1.0:Prelude a93a9400cc0c816c2ee5f39399baa7a0
import  -/  base-4.10.1.0:System.Environment 29b8ecc18446119a33172a40409ab016
import  -/  base-4.10.1.0:System.IO 1fb8f1d116df69c8750950ac088a90e6
import  -/  ghc-prim-0.5.1.1:GHC.Classes 64ad5910d03ab188ab9b4adef7487b1e
import  -/  ghc-prim-0.5.1.1:GHC.Types b1fd0716441595db508c1a74387bf394
import  -/  jkfso-haskell-0.1.0.0:HardConstraints b8cce133a0c50166437a32310b787d70
import  -/  jkfso-haskell-0.1.0.0:Input 6fc3a9f46a44920ea6eadc837c4147b3
import  -/  jkfso-haskell-0.1.0.0:Parser 6b1b2e52d986ebe1a0394b1a1b0f7802
import  -/  jkfso-haskell-0.1.0.0:SoftConstraints 5e5ab34aee25158049bb25933a33f568
9d72b2fddb818bcd8919052935e0f1f3
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule3 Main.$trModule1) -}
3108ceeaf5a318be844de422b45de9d8
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule2) -}
e5875966b74dad2d29772660b8a75e33
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Main"#) -}
33bd129667974f0a0ba4a893af79107d
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule4) -}
d026be77cb9ced20e35a61514e0458aa
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
c85431048e5b3cf0babe03c3301606bb
  forcedMatchValid :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: [GHC.Types.Char]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : ipv ipv1
                   -> case GHC.Base.eqString wild Main.forcedMatchValid1 of wild1 {
                        GHC.Types.False -> GHC.Types.[] @ GHC.Types.Char
                        GHC.Types.True -> wild } }) -}
e79e8ce72c2469fbef07d25e09d2fbaa
  forcedMatchValid1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Main.forcedMatchValid2) -}
283366ba75e68541f557326e2a148bc0
  forcedMatchValid2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("No valid solution possible!"#) -}
16c8b5a7e0fffcc12f6a3958110c69b9
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
9b4b21b4c54864445b1f4f79758c75aa
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (Foreign.Marshal.Alloc.allocaBytesAligned
                         @ Foreign.C.Types.CInt
                         @ (GHC.Base.Maybe [GHC.Base.String])
                         Foreign.Storable.$fStorableBool7
                         Foreign.Storable.$fStorableBool7
                         System.Environment.getArgs2
                           `cast`
                         (<GHC.Ptr.Ptr Foreign.C.Types.CInt>_R
                          ->_R Sym (GHC.Types.N:IO[0] <GHC.Base.Maybe [GHC.Base.String]>_R)))
                        `cast`
                      (GHC.Types.N:IO[0] <GHC.Base.Maybe [GHC.Base.String]>_R)
                        s of ds2 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   GHC.Base.Nothing
                   -> case GHC.Environment.getFullArgs1
                             ipv of ds3 { (#,#) ipv2 ipv3 ->
                      Main.main2
                        ipv2
                        (case System.Environment.dropRTSArgs ipv3 of wild1 {
                           [] -> GHC.List.scanl2 @ GHC.Base.String : ds4 xs -> xs }) }
                   GHC.Base.Just argv
                   -> Main.main2 ipv (GHC.List.tail @ GHC.Base.String argv) } }) -}
01401f56b02d35ad2529bd7c50405616
  main2 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> [GHC.Base.String]
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S,U><L,U> -}
77b2e632fc996b949cdd4c2d7e790047
  main3 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
f41c644936840ab3bfaafe2b72e53e4b
  makeSolution :: GHC.Base.String -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><L,1*U(U)>,
     Unfolding: (\ (matches :: GHC.Base.String)
                   (quality :: GHC.Types.Int) ->
                 GHC.CString.unpackAppendCString#
                   Main.makeSolution3
                   (let {
                      n :: [GHC.Types.Char]
                      = GHC.CString.unpackAppendCString#
                          Main.makeSolution2
                          (case quality of ww2 { GHC.Types.I# ww3 ->
                           case GHC.Show.$wshowSignedInt
                                  0#
                                  ww3
                                  (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                           GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                    } in
                    case matches of wild {
                      [] -> n
                      : x xs
                      -> GHC.Base.++
                           @ GHC.Types.Char
                           (GHC.Types.:
                              @ GHC.Types.Char
                              x
                              (Data.OldList.prependToAll @ GHC.Types.Char Main.makeSolution1 xs))
                           n })) -}
a268d5891b483cd88ebd517c05f16148
  makeSolution1 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ' '#) -}
7dc59637e5c84f05031c1a93eac29955
  makeSolution2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("; Quality: "#) -}
98806967c7349cf3258255844c6f9579
  makeSolution3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Solution "#) -}
d62221de0a4967ca1d032836a3e1e0a4
  solutionValid :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

