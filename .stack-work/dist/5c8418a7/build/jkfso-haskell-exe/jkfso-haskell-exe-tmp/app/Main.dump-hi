
==================== FINAL INTERFACE ====================
2018-03-12 20:31:28.5031391 UTC

interface main:Main 8022
  interface hash: 6370ae15a165c7f71b157114164ab91d
  ABI hash: 3c83b72c8578de9a1a6050d98c7b3b97
  export-list hash: 28b9ee1cd8e908da99b7f05dc4c9a236
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: b9c7e8ff195830d0fc56c19d3fd5fa92
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.checkComments
  Main.forcedMatchValid
  Main.hasCommentChar
  Main.main
  Main.makeSolution
  Main.solutionValid
module dependencies:
package dependencies: base-4.10.1.0* ghc-prim-0.5.1.1
                      integer-gmp-1.0.1.0 jkfso-haskell-0.1.0.0
orphans: base-4.10.1.0:GHC.Float base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Type.Equality base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
import  -/  base-4.10.1.0:Data.Foldable 4349255461f1285ad885cd2301205c36
import  -/  base-4.10.1.0:Data.List e5312e282ad78d8152090e079f862b53
import  -/  base-4.10.1.0:Data.OldList fdea655c7bec488a3994df222c677ab7
import  -/  base-4.10.1.0:GHC.Base 8f949d675e49677c272f02ab7a85fe18
import  -/  base-4.10.1.0:GHC.List 1bb0adf79553530dc898796596e53188
import  -/  base-4.10.1.0:GHC.Show 927ef590f679632bf94869e8018e5b48
import  -/  base-4.10.1.0:Prelude a93a9400cc0c816c2ee5f39399baa7a0
import  -/  base-4.10.1.0:System.Environment 29b8ecc18446119a33172a40409ab016
import  -/  base-4.10.1.0:System.IO 1fb8f1d116df69c8750950ac088a90e6
import  -/  ghc-prim-0.5.1.1:GHC.Classes 64ad5910d03ab188ab9b4adef7487b1e
import  -/  ghc-prim-0.5.1.1:GHC.Types b1fd0716441595db508c1a74387bf394
import  -/  jkfso-haskell-0.1.0.0:HardConstraints e0987c393cf3de8260f4ac7dbecdeac7
import  -/  jkfso-haskell-0.1.0.0:Input 6fc3a9f46a44920ea6eadc837c4147b3
import  -/  jkfso-haskell-0.1.0.0:Parser 8eb0dc2b4febf30e20663b464ea9e604
import  -/  jkfso-haskell-0.1.0.0:SoftConstraints 490ba58a8a4eba1b5afd8e2b3d7a0f0c
9d72b2fddb818bcd8919052935e0f1f3
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule3 Main.$trModule1) -}
3108ceeaf5a318be844de422b45de9d8
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule2) -}
e5875966b74dad2d29772660b8a75e33
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Main"#) -}
33bd129667974f0a0ba4a893af79107d
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule4) -}
d026be77cb9ced20e35a61514e0458aa
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
4dc857a0e88819f9a4057e4c662c048c
  checkComments :: [GHC.Base.String] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
c85431048e5b3cf0babe03c3301606bb
  forcedMatchValid :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: [GHC.Types.Char]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : ipv ipv1
                   -> case GHC.Base.eqString wild Main.forcedMatchValid1 of wild1 {
                        GHC.Types.False -> GHC.Types.[] @ GHC.Types.Char
                        GHC.Types.True -> wild } }) -}
e79e8ce72c2469fbef07d25e09d2fbaa
  forcedMatchValid1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Main.forcedMatchValid2) -}
283366ba75e68541f557326e2a148bc0
  forcedMatchValid2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("No valid solution possible!"#) -}
f778f4d2223829516482e20da21e315e
  hasCommentChar ::
    GHC.Base.String -> GHC.Base.String -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
16c8b5a7e0fffcc12f6a3958110c69b9
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
9b4b21b4c54864445b1f4f79758c75aa
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (Foreign.Marshal.Alloc.allocaBytesAligned
                         @ Foreign.C.Types.CInt
                         @ (GHC.Base.Maybe [GHC.Base.String])
                         Foreign.Storable.$fStorableBool7
                         Foreign.Storable.$fStorableBool7
                         System.Environment.getArgs2
                           `cast`
                         (<GHC.Ptr.Ptr Foreign.C.Types.CInt>_R
                          ->_R Sym (GHC.Types.N:IO[0] <GHC.Base.Maybe [GHC.Base.String]>_R)))
                        `cast`
                      (GHC.Types.N:IO[0] <GHC.Base.Maybe [GHC.Base.String]>_R)
                        s of ds2 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   GHC.Base.Nothing
                   -> case GHC.Environment.getFullArgs1
                             ipv of ds3 { (#,#) ipv2 ipv3 ->
                      Main.main2
                        ipv2
                        (case System.Environment.dropRTSArgs ipv3 of wild1 {
                           [] -> GHC.List.scanl2 @ GHC.Base.String : ds4 xs -> xs }) }
                   GHC.Base.Just argv
                   -> Main.main2 ipv (GHC.List.tail @ GHC.Base.String argv) } }) -}
01401f56b02d35ad2529bd7c50405616
  main2 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> [GHC.Base.String]
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S,U><L,U> -}
77b2e632fc996b949cdd4c2d7e790047
  main3 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
f41c644936840ab3bfaafe2b72e53e4b
  makeSolution :: GHC.Base.String -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><L,1*U(U)>,
     Unfolding: (\ (matches :: GHC.Base.String)
                   (quality :: GHC.Types.Int) ->
                 GHC.CString.unpackAppendCString#
                   Main.makeSolution3
                   (let {
                      n :: [GHC.Types.Char]
                      = GHC.CString.unpackAppendCString#
                          Main.makeSolution2
                          (case quality of ww2 { GHC.Types.I# ww3 ->
                           case GHC.Show.$wshowSignedInt
                                  0#
                                  ww3
                                  (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                           GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                    } in
                    case matches of wild {
                      [] -> n
                      : x xs
                      -> GHC.Base.++
                           @ GHC.Types.Char
                           (GHC.Types.:
                              @ GHC.Types.Char
                              x
                              (Data.OldList.prependToAll @ GHC.Types.Char Main.makeSolution1 xs))
                           n })) -}
a268d5891b483cd88ebd517c05f16148
  makeSolution1 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ' '#) -}
7dc59637e5c84f05031c1a93eac29955
  makeSolution2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("; Quality: "#) -}
98806967c7349cf3258255844c6f9579
  makeSolution3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Solution "#) -}
d62221de0a4967ca1d032836a3e1e0a4
  solutionValid :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

